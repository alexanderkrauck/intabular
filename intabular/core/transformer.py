"""
Safe execution of transformation rules generated by LLM for CSV data mapping.
"""

import re
import ast
from typing import Dict, Any, Union
from .logging_config import get_logger


class TransformationExecutor:
    """Safely executes LLM-generated transformation rules"""
    
    def __init__(self):
        self.logger = get_logger("transformer")
        
        # Safe namespace with allowed modules and functions
        self.safe_namespace = {
            're': re,
            'str': str,
            'int': int,
            'float': float,
            'len': len,
            'min': min,
            'max': max,
            'abs': abs,
            'round': round,
            'bool': bool,
            'list': list,
            'dict': dict,
            'set': set,
            'tuple': tuple,
        }
    
    def execute_transformation(
        self, 
        transformation_rule: str, 
        source_data: Dict[str, Any], 
        current_value: Any = None
    ) -> Any:
        """
        Execute a transformation rule with provided data
        
        Args:
            transformation_rule: Python expression to execute
            source_data: Dictionary of source column data
            current_value: Current value in target column (optional)
            
        Returns:
            Transformed value
            
        Raises:
            ValueError: If transformation execution fails
        """
        
        if not transformation_rule or transformation_rule.strip() == "":
            return None
            
        # Create execution namespace
        namespace = self.safe_namespace.copy()
        
        # Add source column data - convert to strings and handle None values
        for col_name, value in source_data.items():
            if value is None:
                namespace[col_name] = ""
            elif isinstance(value, str):
                namespace[col_name] = value
            else:
                namespace[col_name] = str(value)
        
        # Add current target value
        if current_value is None:
            namespace['current'] = ""
        elif isinstance(current_value, str):
            namespace['current'] = current_value
        else:
            namespace['current'] = str(current_value)
        
        try:
            self.logger.debug(f"Executing transformation: {transformation_rule}")
            self.logger.debug(f"With data: {list(source_data.keys())}")
            
            # Execute the transformation rule
            result = eval(transformation_rule, {"__builtins__": {}}, namespace)
            
            self.logger.debug(f"Transformation result: {result}")
            return result
            
        except Exception as e:
            error_msg = f"Failed to execute transformation '{transformation_rule}': {e}"
            self.logger.error(error_msg)
            raise ValueError(error_msg)
    
    def validate_transformation_rule(self, transformation_rule: str) -> bool:
        """
        Validate that a transformation rule is safe to execute
        
        Args:
            transformation_rule: Python expression to validate
            
        Returns:
            True if safe, False otherwise
        """
        
        if not transformation_rule or transformation_rule.strip() == "":
            return False
            
        try:
            # Parse the expression into an AST
            tree = ast.parse(transformation_rule, mode='eval')
            
            # Check for dangerous operations
            for node in ast.walk(tree):
                if isinstance(node, (ast.Import, ast.ImportFrom)):
                    return False
                if isinstance(node, ast.Call):
                    # Check for dangerous function calls
                    if isinstance(node.func, ast.Name):
                        if node.func.id in ['exec', 'eval', 'compile', 'open', '__import__']:
                            return False
                    elif isinstance(node.func, ast.Attribute):
                        # Check for dangerous method calls
                        if node.func.attr in ['write', 'read', 'delete', 'remove']:
                            return False
                            
            return True
            
        except SyntaxError:
            return False
        except Exception:
            return False


def apply_column_mapping(
    mapping_result: Dict[str, Any], 
    source_row: Dict[str, Any], 
    current_value: Any = None
) -> Any:
    """
    Apply a column mapping to transform source data
    
    Args:
        mapping_result: Result from strategy creation with transformation_type and transformation_rule
        source_row: Dictionary of source column data for this row
        current_value: Current value in target column (for merging)
        
    Returns:
        Transformed value or None if no mapping
    """
    
    if mapping_result['transformation_type'] == 'none':
        return None
    elif mapping_result['transformation_type'] == 'format':
        executor = TransformationExecutor()
        return executor.execute_transformation(
            mapping_result['transformation_rule'], 
            source_row, 
            current_value
        )
    elif mapping_result['transformation_type'] == 'llm_format':
        # First apply the format transformation
        executor = TransformationExecutor()
        intermediate_result = executor.execute_transformation(
            mapping_result['transformation_rule'], 
            source_row, 
            current_value
        )
        # TODO: Pass to LLM for further processing
        # For now, just return the intermediate result
        return intermediate_result
    else:
        raise ValueError(f"Unknown transformation type: {mapping_result['transformation_type']}") 